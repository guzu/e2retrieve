
DIVERS NOMS:
============================
* e2forensic  (médecin légiste)
* e2pullout   (extirper)
* e2rootout   (extirper)
* e2extricate (extirper)
* e2extirpate (extirper)
* e2extort    (extorquer)
* e2exhumator (exhumer)
* e2retrieve
* e2revival
* e2regenerate


 PART
======
* Une fois les offset trouvés, vérifier qu'il n'y a pas de chevauchement ( offset1+size1 < offset2 )

* quand une partie n'est pas alignée et qu'on a un superblock et la table des "group descriptors",
  on peut scanner la partie en question pour y rechercher la table des "group descriptors".
  On doit également pouvoir scanner une partie à la recherche de la table des
  descripteurs de groupe, sachant que les offsets de chaque élément de la table sont multiple de la
  taille de bloc et que pour certains, ils sont normalement à des numeros de blocs consécutifs.

DIVERS
======
* Plutôt que de charger certaines structures en entier en mémoire, si elle sont tronquées
  on peut tout de même essayer d'obtenir l'infos en calculant son "adresse" directe (valable
  pour les bitmap par exemple). Mais cela est peut-être trop lent (comptons sur le cache :o)

* Prendre en compte le flag sparse_super (mais je vois plus pourquoi j'ai pensé à ça :o)

* Vérifier qu'on ne nous passe pas deux fois le même fichier en argument

* Tester le numero d'inoeud pour voir s'il est plus grand que le nombre maxi d'inoeud
  possible dans le FS

* à la reprise d'un scan interrompu, il faut reprendre un peu avant (au moins la taille de la
  signature), ou bien enregistrer la taille de 'copied' (voire même le dernier buffer et tous
  les paramètres associés).

* dumper les fichiers avec leur date de modification et d'access (voir utime, la date de création
  est gérée par le système, et on ne peut pas la rétablir) et permissions initiales (voir chmod et fchmod)

* vérifier que le type du fichier renseigné dans le répertoire est le même que celui dans l'inoeud

* lorsque qu'on dump un fichier, on vérifie que celui ci est bien du type attendu, un message est alors
  affiché, mais il faut s'assurer que ce fichier sera au moins dumpé en tant que inode orphelin

* quand aucun superblock n'a été trouvé, on peut peut-être essayé de trouver certains des champs
  du superblock de façon heuristique (en utilisant par exemple une souche d'un répertoire qui ne
  tiendrait que dans un seul bloc, en utilisant le fait que le dernier élément de la table est aligné
  sur la taille du bloc; on peut également se limiter aux souches de répertoires vides, ce qui est
  plus simple). 
  Reste que certains champs du superblock vont être difficilement devinables voire pas devinables
  du tout.

REPERTOIRES
===========
* La souche d'un repertoire a une offset alignee sur un multiple de la taille du bloc
  Si une souche n'est pas alignee (il faut qu'elle appartienne a une partie alignee) alors
  on peut la jeter.

* Ne pas oublier que les noms des entrées de répertoires ont une longueur multiple de 4 octets et
  que les octets en trop sont mis à zero.

* Lors de la recherche des répertoires, il est possible d'éxumer un vieux répertoire. Soit il
  n'existe effectivement plus, soit il a été réalloué pour un autre répertoire ou un fichier.

* vérifier (si possible) que le bloc d'une souche est marqué comme utilisé

* lorsqu'une souche est OK, si on a trouvé une souche de même numero d'inoeud on la marque KO

* quand on cherche les inoeuds orphelins, on cherche d'abord les inoeuds de répertoires; on ne
  peut pas avoir la souche, mais avoir les blocs suivants du coup. Puis on réinsert les répertoires
  dans l'arbre général, qu'on réordonne. Et enfin, on cherche les inoeuds du répertoire trouvé.

* si on a "assez" de souche dans une partie non alignée, on peut essayer de trouver les inoeuds
  de ces répertoires pour déterminer l'alignement le plus *probable*.
